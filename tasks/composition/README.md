# Сумма произведений

Цель этой задачи — научиться работать с аргументами командной строки, а также с указателями и динамическим выделением памяти вручную.

В этой задаче нельзя пользоваться никакими классами и функциями из стандартной библиотеки, кроме ввода/вывода в поток (cin, cout). Все выделения памяти надо делать вручную, использовать std::vector и ему подобные контейнеры нельзя.

Даны k массивов целых чисел, чьи размеры равны соответственно 
n1, n2, …, nk. Обозначим данные массивы за a1, …, ak. Ваша задача — посчитать и вывести сумму произведений вида a1[i1] ⋅ … ⋅ ak[ik] по всевозможным кортежам попарно различных индексов (i1, …, ik), где каждый индекс лежит в соответствующих пределах.

Ваша программа должна использовать O(k + n1 + … + nk) памяти. Выделять память «с запасом, чтоб точно хватило» нельзя.

Важно! В качестве компилятора необходимо выбирать make GCC C++17, в противном случае вы не сможете получить ОК по задаче (make нужен для того, чтобы тестирующая система могла запустить вашу программу с аргументами командной строки!).

## Формат ввода
Числа n1, …, nk вводятся в виде параметров командной строки. После чего через стандартный поток ввода вводятся элементы массивов один за другим, то есть сначала все элементы первого массива, затем все элементы второго, и т.д.

Например, ваша программа может быть вызвана так: ./a.out 7 2 4 8 9

Это будет означать, что k=5, а размеры массивов равны соответственно a1 = 7, …, a5 = 9.

## Формат вывода
Выведите единственно число — ответ на задачу.

## Примечания
Гарантируется, что все элементы массивов влезают в int, а ответ влезает в long long.
Наличие в условии задачи 1-индексации не означает, что в вашей программе индексация должна идти с 1 :)
Не пытайтесь придумать какой-то умный алгоритм, избежав перебора. Это NP-трудная задача (даже хуже, чем просто NP-трудная, но забейте). Цель — аккуратно и правильно написать перебор, корректно выделив и освободив все динамические массивы.